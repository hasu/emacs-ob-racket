The body is evaluated, but nothing is output into the buffer.
#+BEGIN_SRC racket :results silent
  'not-printed
#+END_SRC

The body is treated as a =racket= language expression, and the result is output.
#+BEGIN_SRC racket :results value
  (define two 2)
  two
  (* two two two)
#+END_SRC

#+RESULTS:
: 8

The body is in =racket=, and top-level values get output.
#+BEGIN_SRC racket :results output
  #lang racket
  (set 1 2 3) 
#+END_SRC

#+RESULTS:
: (set 1 3 2)

The body is in =racket/base=, and top-level values get output.
#+BEGIN_SRC racket :results output
  #lang racket/base
  1
  2
  3
#+END_SRC

#+RESULTS:
: 1
: 2
: 3

The body is in =racket/base=, and the value gets output.
#+BEGIN_SRC racket :results value :prologue "#lang racket/base"
  (list 1 2)
#+END_SRC

#+RESULTS:
: (1 2)

The body is in =racket=, and we are passing in values for it.
#+BEGIN_SRC racket :results value :var x=5 :var y=6
  (/ x y)
#+END_SRC

#+RESULTS:
: 5/6

The body is in =racket/base=, and we are passing in values for it.
#+BEGIN_SRC racket :results value :var x=5 :var y=6 :prologue "#lang racket/base"
  (list x y)
#+END_SRC

#+RESULTS:
: (5 6)

As above, but now we require a library not otherwise available in =racket/base=.
#+BEGIN_SRC racket :results value :var x=5 :var y=6 :prologue "#lang racket/base\n(require racket/set)"
  (set x y)
#+END_SRC

#+RESULTS:
: #<set: 5 6>

Being explicit about =#lang= and =require=.
#+BEGIN_SRC racket :results output
  #lang racket/base
  (require racket/set)
  (for/set ([i (in-range 10)])
    i)
#+END_SRC

#+RESULTS:
: (set 1 5 9 3 7 0 4 8 2 6)

Run code in the listing via a submodule that is not shown in the listing itself.
#+BEGIN_SRC racket :results output :var x=5 :var y=6 :prologue "#lang racket/base\n(require racket/set)" :epilogue "(module* main #f (run))"
  (define (run)
    (write (set x y)))
#+END_SRC

#+RESULTS:
: #<set: 5 6>
